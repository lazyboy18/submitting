#define _CRT_SECURE_NO_WARNINGS 
#include<stdio.h>



//int main()
//{
//	char*p = "abcdef";
//	printf("%d ", strlen(&p));
//
//}

//好好思考什么是指针与地址吧
//
//int main()
//{
//	int arr[3][4] = { 0 };
//	printf("%d\n", sizeof(arr));//48  arr代表整个数组
//	printf("%d\n", sizeof(arr[0][0]));//4,
//	printf("%d\n", sizeof(arr[0]));//16  ，arr[0]表示访问第一行数组，arr[0]可以看成第一行数组的数组名
//	printf("%d\n", sizeof(arr[0]+1));//4  ，arr[0]表示第一数组名，此时arr[0]表示第一行数组的首元素地址,
//	//arr[0]+1表示第一行数组的第二个元素的地址
//	printf("%d\n", sizeof(arr[0] + 0));//4 
//	printf("%d\n", sizeof(*(arr[0] + 1)));//4 ,第一行第二个元素
//	printf("%d\n", sizeof(arr+1));  //二维数组的数组名如果不单独放置则是arr数组的首元素地址，
//	//即第一行数组的地址（把二维数组看成一维数组），arr+1就是第二行数组的地址
//	printf("%d\n", sizeof(*(arr + 1)));//*(arr+1)表示找到第二行元素，*(arr+1)=arr[1],计算第二行的大小
//	printf("%d\n", sizeof(&arr[0] + 1));//4，arr[0]表示第一数组名，
//   //&数组名等于第一行数组的地址，加一等于第二行数组的地址
//	printf("%d\n", sizeof(*arr));//16，*arr表示第一行，arr表示第一行的地址
//	printf("%d\n", sizeof(arr[3]));//16 ,sizeof不会访问，只求类型大小
//
//
//}


//面试题1
//int main()
//{
//	int a[5] = { 1, 2, 3, 4, 5 };
//	int*ptr = (int*)(&a + 1);//(int*)将(&a+1)的类型强制转化成为整型指针，减一向前跳到4个字节
//	printf("%d %d", *(a + 1), *(ptr - 1));//2 5
//	//&a表示整个数组的地址，&a+1表示整个数组的地址向后跳动20个字节，ptr是整型指针
//	//-1向前跳到4个字节来到数组第五个元素的地址
//	return 0;
//}

//面试题2
//struct Test
//{
//	int Num;
//	char*pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//
//}*p;

//假设p的值为0x100000
//已知，结构体Test类型的变量大小是20个字节
//
//int main()
//{
//	p = (struct Test*)0x100000;
//	printf("%p\n", p + 0x1);//0x00100014,p的类型是结构体Test，所以加1时跳过20个字节
//	printf("%p\n",(unsigned long)p + 0x1);//0x00100001,p被强制类型转化为无符号长整型
//	//,实际上p就是一个数字，加1等于0x00100001
//	printf("%p\n", (unsigned int*)p + 0x1);
//	//p被强制类型转化为整型指针，加一跳过4个字节，结果为0x00100004
//	//%p的意思是以地址的形式打印
//
//}

//面试题3
//特有价值的题

//int main()
//{
//	int a[4] = { 1, 2, 3, 4 };
//	int *ptr1 = (int*)(&a + 1);
//	int*ptr2 = (int*)((int)a + 1);
//	printf("%x\n%x\n", ptr1[-1], *ptr2);
//	//4    0x02000000
//
//	//假设a的地址为0x00000005  
//	//a[0]能访问四个字节，01 00 00 00
//	//a[1]也能访问四个字节， 02 00 00 00
//	//那么(int)a+1的值为6
//	//再强制类型转化为int*则为0x00000006
//	//*ptr2能访问四个字节 ，00 00 00 02
//	//再以十六进制的形式进行打印，则为0x02000000
//	//2000000
//
//	return 0;
//   //地址本身有自己的类型，同一个地址本身有不同的意义
//  //
//}

//面试题4
//int main()
//{
//	int a[3][2] = { (0, 1), (2, 3), (4, 5) };
//	//注意逗号表达式
//	//二维数组的排序{{1,3},{5,0},{0,0}};
//	int *p = a[0];
//	printf("%d", p[0]);//1
//	//p[0]==a[0][0]-->a代表第一行数组地址，a[0]=*(a+0)表示找到了该数组
//	//此时*(a+0)表示第一行数组的首元素的地址，*(*(a+0)+0)表示打开该地址，找到元素
//	//p[0] = a[0][0];
//	//a[0]单独表示第一行数组的地址
//	//a[0][0]=*(a[0]+0),在右括号里面的a[0]表示第一行数组的
//	//首元素的地址，a[0]+0依旧表示第一行数组的首元素的地址
//	return 0;
//	//务必要知道，*表示通过地址找到了地址指向的那个对象
//}

//面试题5
//int main()
//{
//	int a[5][5];
//	int(*p)[4];
//	p = a;
//	printf("%p, %d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
//	//FFFFFFFC    -4
//	//画出数组结构图即可
//	//两个指针相减等于指针间的元素个数
//	return 0;
//}


//int main()
//{
//	char*a[] = { "work", "at", "alibaba" };
//	char**pa = a;//a代表数组首元素的地址，该指针所指向的类型是char
//	//指针pa的类型是char**，所指向的类型是char*
//	pa++;//pa+1跳过一个char*
//	//int a=10;int*pa=&a; pa+1表示跳过一个整型
//	printf("%s\n", *pa);
//	return 0;
//}

int main()
{
	char*c[] = { "ENTER", "NEW", "POINT", "FIRST" };
	//c[]数组的元素是指针，单独一个c代表首元素地址，即指针的地址
	//所以c是二级指针，
	char**cp[] = { c + 3, c + 2, c + 1, c };
	//指针间加减整数只能在同级指针间跳动
	char***cpp = cp;
	//cp是二级指针数组的地址，cpp是个三级指针，存贮着二级指针
	//对cpp解引用操作，也就是打开二级指针的地址可以得到二级指针c+系列
	//对二级指针解引用，也就是说打开一级指针的地址可以得到一级指针
	printf("%s\n", **++cpp);//POINT
	printf("%s\n", *--*++cpp + 3);//ER
	printf("%s\n", *cpp[-2] + 3);//ST
	printf("%s\n", cpp[-1][-1] + 1);//EW
	//注意++cpp实现cpp自增后cpp值不会恢复原状
	//cpp[-2]操作不会使cpp自增
	//画图好好品味！！！
	//注意：元素(取地址)-->指针(解引用)--元素
	//元素（取地址）-->指针(取地址)-->二级指针(取地址)-->三级指针(取地址)-->四级指针.......
	//
	return 0;
}